# **프로젝트 요구사항 문서: My TypeScript Proxy Server**

다음 표는 My TypeScript Proxy Server의 기능 요구사항을 설명합니다.

| 요구사항 ID | 설명                      | 사용자 스토리                                                                                                          | 기대 행동/결과                                                                                                                                                                                |
| ----------- | ------------------------- | ---------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| KR001       | 기본 HTTP 요청/응답 처리  | 사용자는 프록시 서버를 통해 기본적인 HTTP 요청을 보내고 응답을 받을 수 있어야 합니다.                                          | 시스템은 들어오는 HTTP 요청 (GET, POST 등)을 파싱하고, 적절한 로직을 실행한 후, 유효한 HTTP 응답 (상태 코드, 헤더, 본문)을 생성하여 클라이언트에게 반환해야 합니다.                           |
| KR002       | 서블릿 컨테이너 기능 구현 | 개발자는 서블릿과 유사한 형태로 애플리케이션 로직을 작성하고 프록시 서버에 배포할 수 있어야 합니다.                            | 시스템은 특정 인터페이스를 따르는 사용자 정의 코드를 로드하고 실행할 수 있는 컨테이너 환경을 제공해야 합니다. 요청 URL에 따라 적절한 코드가 실행되고, 라이프사이클 관리가 가능해야 합니다.    |
| KR003       | Spring Framework 연동     | 개발자는 개발된 프록시 서버를 Spring Framework 애플리케이션의 내장 서버로 사용할 수 있어야 합니다.                             | 시스템은 Spring Boot 또는 Spring Framework의 표준 서블릿 API 또는 관련 인터페이스와 호환되어야 합니다. Spring 애플리케이션 컨텍스트를 로드하고 요청 처리를 위임할 수 있어야 합니다.           |
| KR004       | Tomcat 호환성 (일부 기능) | 사용자는 기존 Tomcat 기반 애플리케이션의 일부 기능을 수정 없이 또는 최소한의 수정으로 프록시 서버에서 실행할 수 있어야 합니다. | 시스템은 Tomcat의 핵심 기능 중 일부(예: 기본적인 설정 파일 구조, 로깅 방식 등)를 유사하게 구현하거나 호환성을 제공하여 마이그레이션 비용을 줄여야 합니다. (구체적인 호환성 범위는 추후 정의)  |
| KR005       | TypeScript 기반 개발      | 개발자는 프로젝트 전체 코드를 TypeScript를 사용하여 개발하고 관리할 수 있어야 합니다.                                  | 시스템의 모든 코드는 TypeScript로 작성되어야 하며, 타입 안정성을 활용하고 최신 JavaScript 기능을 사용할 수 있어야 합니다. 컴파일 및 빌드 프로세스가 TypeScript 환경에 맞게 구성되어야 합니다. |

## 체크리스트

- [ ] KR001: 기본 HTTP 요청/응답 처리
- [ ] KR002: 서블릿 컨테이너 기능 구현
- [ ] KR003: Spring Framework 연동
- [ ] KR004: Tomcat 호환성 (일부 기능)
- [ ] KR005: TypeScript 기반 개발

## Detail

### `src/core/Server.ts` 구현 계획

1.  **`constructor(port = 8080)`:**
    - 리스닝할 포트 번호(`this.port`)를 저장합니다.
    - `httpServer` 인스턴스는 `null`로 초기화합니다.
2.  **`start()`:**
    - `http.createServer((req, res) => { ... })` 호출:
      - Node.js `http.Server` 인스턴스를 생성하여 `this.httpServer`에 할당합니다.
      - 요청 핸들러 콜백 함수를 등록합니다.
    - **요청 핸들러 콜백 (`(req, res) => { ... }`) 내부:**
      - `console.log` 등을 사용하여 요청 메소드(`req.method`)와 URL(`req.url`)을 타임스탬프와 함께 로깅합니다.
      - `res.statusCode = 200`으로 성공 상태 코드를 설정합니다.
      - `res.setHeader('Content-Type', 'text/plain; charset=utf-8')`으로 응답 콘텐츠 타입을 설정합니다.
      - `res.end('Hello World from My TypeScript Proxy Server!\n')`로 응답 본문을 전송하고 연결을 종료합니다.
      - _(주석 명시)_ 향후 요청 파싱, 라우팅, 실제 핸들러 호출 로직이 추가될 위치입니다.
    - `this.httpServer.on('error', (error) => { ... })` 호출:
      - 서버 자체에서 발생하는 오류(예: 포트 충돌)를 처리하기 위한 이벤트 리스너를 등록합니다.
      - 오류 발생 시 `console.error`로 에러 메시지를 로깅합니다.
      - _(주석 명시)_ 실제 서비스에서는 더 정교한 에러 처리(리소스 정리, 재시작 등)가 필요합니다.
    - `this.httpServer.listen(this.port, () => { ... })` 호출:
      - 저장된 포트 번호(`this.port`)로 서버 리스닝을 시작합니다.
      - 리스닝 시작 성공 시 실행될 콜백 함수를 등록합니다.
    - **Listen 콜백 (`() => { ... }`) 내부:**
      - `this.httpServer.address()`를 호출하여 실제 할당된 주소 정보(포트 포함)를 가져옵니다.
      - `console.log`를 사용하여 서버가 리스닝 중인 포트를 명확하게 로깅합니다.
3.  **`stop()`:**
    - `if (this.httpServer && this.httpServer.listening)` 조건문:
      - `httpServer` 객체가 존재하고, 현재 리스닝 상태인지 확인합니다.
    - `this.httpServer.close((error) => { ... })` 호출 (조건 만족 시):
      - 서버의 신규 연결 수신을 중단하고, 기존 연결이 완료되면 서버를 완전히 닫습니다.
      - 서버 닫기 작업 완료 후 실행될 콜백 함수를 등록합니다.
    - **Close 콜백 (`(error) => { ... }`) 내부:**
      - `if (error)` 조건문: 서버를 닫는 중 오류가 발생했는지 확인합니다.
      - 오류 발생 시 `console.error`로 에러를 로깅하고 함수를 종료합니다.
      - 오류가 없으면 `console.log('Server stopped.')`로 서버 중지 완료 메시지를 로깅합니다.
    - `else` 블록 (조건 불만족 시):
      - `console.log('Server is not running.')`으로 서버가 실행 중이 아님을 로깅합니다.

### `src/index.ts` 구현 계획

1.  `Server` 클래스 인스턴스를 생성합니다 (기본 포트 8080 사용).
2.  생성된 `server.start()` 메소드를 호출하여 서버를 시작합니다.
3.  **우아한 종료(Graceful Shutdown) 처리:**
    - `process.on('SIGINT', ...)` 및 `process.on('SIGTERM', ...)` 리스너를 등록하여 종료 시그널을 감지합니다.
    - **시그널 수신 시:**
      - "서버 종료 시작" 로그를 출력합니다.
      - `server.stop()`을 호출하여 신규 요청 수신을 중단하고 기존 연결 처리를 시도합니다.
      - **(중요)** `server.stop()`이 완전히 완료될 때까지 기다립니다 (비동기 처리 필요).
      - (필요시) DB 연결 등 다른 리소스 정리 로직을 수행합니다.
      - "서버 완전 종료" 로그를 출력합니다.
      - `process.exit(0)`을 호출하여 프로세스를 정상 종료합니다.
    - (선택 사항) 종료 프로세스가 너무 오래 걸리는 것을 방지하기 위해 타임아웃을 설정하고, 타임아웃 발생 시 강제 종료(`process.exit(1)`)하는 로직을 추가할 수 있습니다.
